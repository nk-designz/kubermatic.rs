/*
 * Kubermatic Kubernetes Platform API
 *
 * This spec describes possible operations which can be made against the Kubermatic Kubernetes Platform API.
 *
 * The version of the OpenAPI document: 2.21
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct OpenstackCloudSpec {
    #[serde(rename = "applicationCredentialID", skip_serializing_if = "Option::is_none")]
    pub application_credential_id: Option<String>,
    #[serde(rename = "applicationCredentialSecret", skip_serializing_if = "Option::is_none")]
    pub application_credential_secret: Option<String>,
    #[serde(rename = "credentialsReference", skip_serializing_if = "Option::is_none")]
    pub credentials_reference: Option<Box<crate::models::GlobalObjectKeySelector>>,
    #[serde(rename = "domain", skip_serializing_if = "Option::is_none")]
    pub domain: Option<String>,
    /// Enable the `enable-ingress-hostname` cloud provider option on the Openstack CCM. Can only be used with the external CCM and might be deprecated and removed in future versions as it is considered a workaround for the PROXY protocol to preserve client IPs. +optional
    #[serde(rename = "enableIngressHostname", skip_serializing_if = "Option::is_none")]
    pub enable_ingress_hostname: Option<bool>,
    /// FloatingIPPool holds the name of the public network The public network is reachable from the outside world and should provide the pool of IP addresses to choose from.  When specified, all worker nodes will receive a public ip from this floating ip pool  Note that the network is external if the \"External\" field is set to true
    #[serde(rename = "floatingIPPool", skip_serializing_if = "Option::is_none")]
    pub floating_ip_pool: Option<String>,
    /// Set a specific suffix for the hostnames used for the PROXY protocol workaround that is enabled by EnableIngressHostname. The suffix is set to `nip.io` by default. Can only be used with the external CCM and might be deprecated and removed in future versions as it is considered a workaround only.
    #[serde(rename = "ingressHostnameSuffix", skip_serializing_if = "Option::is_none")]
    pub ingress_hostname_suffix: Option<String>,
    /// IPv6SubnetID holds the ID of the subnet used for IPv6 networking. If not provided, a new subnet will be created if IPv6 is enabled. +optional
    #[serde(rename = "ipv6SubnetID", skip_serializing_if = "Option::is_none")]
    pub ipv6_subnet_id: Option<String>,
    /// IPv6SubnetPool holds the name of the subnet pool used for creating new IPv6 subnets. If not provided, the default IPv6 subnet pool will be used. +optional
    #[serde(rename = "ipv6SubnetPool", skip_serializing_if = "Option::is_none")]
    pub ipv6_subnet_pool: Option<String>,
    /// Network holds the name of the internal network When specified, all worker nodes will be attached to this network. If not specified, a network, subnet & router will be created  Note that the network is internal if the \"External\" field is set to false
    #[serde(rename = "network", skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// A CIDR range that will be used to allow access to the node port range in the security group to. Only applies if the security group is generated by KKP and not preexisting. If NodePortsAllowedIPRange nor NodePortsAllowedIPRanges is set, the node port range can be accessed from anywhere.
    #[serde(rename = "nodePortsAllowedIPRange", skip_serializing_if = "Option::is_none")]
    pub node_ports_allowed_ip_range: Option<String>,
    #[serde(rename = "nodePortsAllowedIPRanges", skip_serializing_if = "Option::is_none")]
    pub node_ports_allowed_ip_ranges: Option<Box<crate::models::NetworkRanges>>,
    #[serde(rename = "password", skip_serializing_if = "Option::is_none")]
    pub password: Option<String>,
    /// project, formally known as tenant.
    #[serde(rename = "project", skip_serializing_if = "Option::is_none")]
    pub project: Option<String>,
    /// project id, formally known as tenantID.
    #[serde(rename = "projectID", skip_serializing_if = "Option::is_none")]
    pub project_id: Option<String>,
    #[serde(rename = "routerID", skip_serializing_if = "Option::is_none")]
    pub router_id: Option<String>,
    #[serde(rename = "securityGroups", skip_serializing_if = "Option::is_none")]
    pub security_groups: Option<String>,
    #[serde(rename = "subnetID", skip_serializing_if = "Option::is_none")]
    pub subnet_id: Option<String>,
    /// Used internally during cluster creation
    #[serde(rename = "token", skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    /// Whether or not to use Octavia for LoadBalancer type of Service implementation instead of using Neutron-LBaaS. Attention:Openstack CCM use Octavia as default load balancer implementation since v1.17.0  Takes precedence over the 'use_octavia' flag provided at datacenter level if both are specified. +optional
    #[serde(rename = "useOctavia", skip_serializing_if = "Option::is_none")]
    pub use_octavia: Option<bool>,
    #[serde(rename = "useToken", skip_serializing_if = "Option::is_none")]
    pub use_token: Option<bool>,
    #[serde(rename = "username", skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

impl OpenstackCloudSpec {
    pub fn new() -> OpenstackCloudSpec {
        OpenstackCloudSpec {
            application_credential_id: None,
            application_credential_secret: None,
            credentials_reference: None,
            domain: None,
            enable_ingress_hostname: None,
            floating_ip_pool: None,
            ingress_hostname_suffix: None,
            ipv6_subnet_id: None,
            ipv6_subnet_pool: None,
            network: None,
            node_ports_allowed_ip_range: None,
            node_ports_allowed_ip_ranges: None,
            password: None,
            project: None,
            project_id: None,
            router_id: None,
            security_groups: None,
            subnet_id: None,
            token: None,
            use_octavia: None,
            use_token: None,
            username: None,
        }
    }
}


